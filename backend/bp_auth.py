import logging
import traceback
import datetime
import pytz
import re
from urllib import response

from flask import (
    Blueprint, redirect, g, make_response, render_template, request, session, url_for, current_app, Response, jsonify
)
from authlib.jose import jwt
from werkzeug.security import check_password_hash, generate_password_hash
from models import MST_USER, TRN_REFRESH_TOKEN
import secret
from postgresql_db import db

bp = Blueprint('auth', __name__, url_prefix='/auth', template_folder='')
dbs = db.session

'''
iss (issuer): jwt's issuser, use domain.
exp (expiration time): expiration time, after this time resource can not be used.
sub (subject): must be globally unique, use email or uuid generated by email.
aud (audience): refer to the Resource Servers that should accept the token.
nbf (Not Before): not before but after be able to use the resource.
iat (Issued At): issued time.
jti (JWT ID): provides a unique identifier for the JWT.
'''

# @bp.route('/signup', methods=['GET'])
# def signup_view():
#     return render_template("index.html")

# http://localhost:5000/user/signup
# {"email":"yugan6688@gmail.com"}
'''
Success code infomation list.
 I001 = New user is created, wait to be sign up.
 I002 = Verify is OK, response access token and refresh token
 I003 = Verify code is correct.
 I004 = Verify code is not correct.
 I005 = User had signed up.
 I006 = Get new access token successed.
 I007 = Expires after VERIFY_EXPIRES_IN seconds after registration and cannot be verified.
'''

# Avoid to access index html directly
@bp.route('/<path:path>')
@bp.route('/<path:path>.html')
def avoid_page(path):
    return 'Not Found', 404

# @bp.route('/signup/<resource>', methods=['GET'])
# def signup_page(resource):
#     if not resource: return 'Not Found', 404
#     return bp.send_static_file("index.html")

@bp.route('/signup', methods=['POST'])
def signup():
    data = request.get_json()
    if (not data): return 'Bad Request', 400
    email = data['email']
    resource = data['resource']
    # not have email to signup
    if not resource or not email or not re.compile(r'[^@]+@[^@]+\.[^@]+').match(email):
        return 'Bad Request', 400
    else:
        mail_server = current_app.mail_server
        msg = current_app.message
        try:
            AUTH = current_app.config['AUTH']
            if resource.upper() in current_app.config['RESOURCE']:
                resource_key = resource.upper()
            else:
                return 'Bad Request', 400
        
            users = dbs.query(MST_USER).filter(MST_USER.email==email, MST_USER.resource_key==resource_key).all()
            # check if had signed up and role cd is 0, delete it.
            if len(users) == 1:
                if users[0].role_cd == 0:
                    dbs.delete(users[0])
                    dbs.flush()
                else:
                    # I005 = User had signed up.
                    return jsonify({'code': 'I005'})

            # generate temp user verification code
            verify_code = secret.get_verify_code(AUTH.VERIFY_CODE_COUNT)

            session['email'] = email
            session['verify_code'] = verify_code
            session['verify_code_created_datetime'] = datetime.datetime.now(pytz.UTC)
                       
            password = generate_password_hash(email, salt_length=20)
            new_one = MST_USER(resource_key=resource_key, password=password, email=email, role_cd=0)
            dbs.add(new_one)
            dbs.flush()

            # use cipher as secret link
            link = request.host_url + 'auth/verify/' + resource_key.lower() + '/' + password[password.rfind('$') + 1:]
            text = msg.template('email_signup.txt', service_name='test service name', verify_code=verify_code, link=link)
            # TODO set subject from i18n
            mail_server.send([email], 'test subject', text)
            dbs.commit()
            
        except Exception as e:
            # E002 = DB exception or email error
            logging.error(traceback.format_exc())
            dbs.rollback()
            return 'Internal Server Error', 500
        
        resp = make_response(jsonify({'code': 'I001'}))   
        return resp
        
@bp.route('/verify/<resource>/<secret_code>', methods=['GET'])
def verify_redirect(resource, secret_code):
    if not resource or not secret_code: return 'Bad Request', 400
    return render_template('verify_redirect.html', resource=resource, secret_code=secret_code)

# check verify code before submit verify post in page.
@bp.route('/verify/check', methods=['POST'])
def check_auth_code():        
    data = request.get_json()
    if not data or 'verifyCode' not in data \
                or 'email' not in data \
                or 'verify_code' not in session \
                or 'email' not in session \
                or 'verify_code_created_datetime' not in session:
        return 'Bad Request', 400
    
    verify_code = data['verifyCode']
    email = data['email']

    # check session info
    if email == session['email'] and verify_code == session['verify_code']:
        cd = session['verify_code_created_datetime']
        expires_time = cd + datetime.timedelta(seconds=current_app.config['AUTH'].VERIFY_EXPIRES_IN)
        # I007 = Expires after VERIFY_EXPIRES_IN seconds after registration and cannot be verified
        if expires_time < datetime.datetime.now(pytz.UTC):
            return jsonify({'code': 'I007'})
        else:
            # I003 = Verify code is correct.
            return jsonify({'code': 'I003'})
    else:
        # I004 = Verify code is not correct.
        return jsonify({'code': 'I004'})

# Verify user's registration by verify code or secret code in mail link.
@bp.route('/verify', methods=['POST'])
def verify():  
    verify_OK = False
    AUTH = current_app.config['AUTH']
                
    if 'verifyCode' in request.form and 'resource' in request.form:
        verify_code = request.form['verifyCode']
        
        resource = request.form['resource']
        resource_key = resource.upper()
        resource_url = current_app.config['RESOURCE'][resource.upper()]['HOME']
        
        # Verify code is OK
        if verify_code == session['verify_code']:
            users = dbs.query(MST_USER).filter(MST_USER.email==session['email'], MST_USER.resource_key==resource_key).all()
            if len(users) == 1:
                one = users[0]
                # redirect to resource page when user has been signed up.
                if one.role_cd > 0:
                    return redirect(resource_url, code=302)
                else:
                    expires_time = one.created_datetime + datetime.timedelta(seconds=AUTH.VERIFY_EXPIRES_IN)
                    now = datetime.datetime.now(tz=expires_time.tzinfo)
                    # Expires after VERIFY_EXPIRES_IN seconds after registration and cannot be verified
                    if expires_time < now:
                        return render_template('verify_timeout.html')
                    else:
                        verify_OK = True
            # Return to the signup page when there is no user in the database
            else:
                return redirect(url_for('index'), code=302)
        else:
            # I004 = Verify code is not correct.
            return jsonify({'code': 'I004'})
            
    elif 'secret_code' in request.form and 'resource' in request.form:
        secret_code = request.form['secret_code']
        
        resource = request.form['resource']
        resource_key = resource.upper()
        resource_url = current_app.config['RESOURCE'][resource.upper()]['HOME']
        
        users = dbs.query(MST_USER).filter(MST_USER.password.endswith('$' + secret_code), 
                                           MST_USER.resource_key==resource_key, MST_USER.role_cd==0).all()

        # check user data
        if len(users) == 1:
            one = users[0]
            # Expires after VERIFY_EXPIRES_IN seconds after registration and cannot be verified
            expires_time = one.created_datetime + datetime.timedelta(seconds=AUTH.VERIFY_EXPIRES_IN)
            now = datetime.datetime.now(tz=expires_time.tzinfo)
            if expires_time < now:
                return render_template('verify_timeout.html')
            elif check_password_hash(one.password, one.email):
                verify_OK = True
                
    if verify_OK:
        try:
            one_count = dbs.query(MST_USER).filter(MST_USER.role_cd != 0).count()
            one.user_name = current_app.metadata['wait_username'][one_count]
            one.password = None
            one.role_cd = 1
            one.update_datetime = now
            
            remote = [request.remote_addr, request.user_agent.string]
            refresh_token = secret.create_refresh_token()
            expiration_datetime = now + datetime.timedelta(days=AUTH.REFRESH_TOKEN_EXPIRATION_TIME)
            
            trn_refresh_token = TRN_REFRESH_TOKEN(user_id=one.user_id,
                                                  resource_key=resource_key,
                                                  refresh_token=refresh_token,
                                                  remote_info=remote,
                                                  expiration_datetime=expiration_datetime)
            dbs.add(trn_refresh_token)
            dbs.commit()

            # Only return refresh token to rediect resource page. Get access token by client. 
            # verify is OK, response refresh token
            resp = make_response(render_template('verified.html', resource_url=resource_url))
            resp.set_cookie('refresh_token', refresh_token, 
                            httponly = AUTH.REFRESH_TOKEN_COOKIE_HTTPONLY, 
                            secure = AUTH.REFRESH_TOKEN_COOKIE_SECURE, 
                            samesite = AUTH.REFRESH_TOKEN_COOKIE_SAMESITE)
            
            # Set refresh token and resource url to session, use this when redirect to resource on page.
            # session['refresh_token'] = refresh_token
            #session['resource_url'] = resource_url
            
            return resp
        
        except Exception as e:
            logging.error(traceback.format_exc())
            dbs.rollback()
            return 'Internal Server Error', 500
    else:
        return 'Bad Request', 400

# validate refresh token and return new access token and refresh token
@bp.route('/token', methods=['GET'])
def get_token():
    
    refresh_token = request.cookies.get("refresh_token")
    if not refresh_token:
        return 'Bad Request', 400
    try:
        token_item = dbs.query(TRN_REFRESH_TOKEN, MST_USER).join(MST_USER, MST_USER.role_cd!=0).\
                filter(TRN_REFRESH_TOKEN.refresh_token == refresh_token).all()
        
        if len(token_item) != 1:
            return 'Bad Request', 400
        else:
            one = token_item[0].MST_USER
            token = token_item[0].TRN_REFRESH_TOKEN
            remote_info = token.remote_info
            aud = current_app.config['RESOURCE'][token.resource_key]['AUDIENCE']
            now = datetime.datetime.now(tz=token.expiration_datetime.tzinfo)

            # Validate remote info is correct, user's resource url is in request, and refresh token is not expirat
            if remote_info[0] == request.remote_addr and\
                remote_info[1] == request.user_agent.string and\
                aud == request.origin and\
                token.expiration_datetime > now:
                    
                AUTH = current_app.config['AUTH']
                remote = [request.remote_addr, request.user_agent.string]
                payload = get_payload(AUTH, one.user_id, aud, remote, one.role_cd)
                
                access_token = secret.create_access_token(AUTH.ACCESS_TOKEN_PRIVATE_KEY, AUTH.ACCESS_TOKEN_ALG, payload)
                refresh_token = secret.create_refresh_token()
                expiration_datetime = now + datetime.timedelta(days=AUTH.REFRESH_TOKEN_EXPIRATION_TIME)
                
                token.remote_info = remote
                token.refresh_token = refresh_token
                token.expiration_datetime = expiration_datetime
                token.update_datetime = now
                
                result = jsonify({'code': 'I006', 'access_token': access_token, 'role_cd': one.role_cd})
                resp = make_response(result)
                resp.set_cookie('refresh_token', refresh_token,
                                httponly=AUTH.REFRESH_TOKEN_COOKIE_HTTPONLY, 
                                secure=AUTH.REFRESH_TOKEN_COOKIE_SECURE, 
                                samesite=AUTH.REFRESH_TOKEN_COOKIE_SAMESITE)
                
                dbs.commit()
                return result
            else:
                return 'Bad Request 3', 400
        
    except Exception as e:
        # E002 = DB exception or email error
        logging.error(traceback.format_exc())
        dbs.rollback()
        return 'Internal Server Error', 500
            
    # TODO set policy to prevent same session multiple visits to set refresh_token
    # update refresh token
    
@bp.route('/verified')
def verified():
    resp = make_response(render_template('verified.html', resource_url='resource_url'))
    return resp

def get_payload(conf, sub, aud, remote, role):
    now = datetime.datetime.now()
    dt_format = '%Y-%m-%d %H:%M:%S'
    return {'iss': conf.ACCESS_TOKEN_DOMAIN, 
            # after ACCESS_TOKEN_EXPIRATION_TIME resource can not be used
            'exp': (now + datetime.timedelta(seconds=conf.ACCESS_TOKEN_EXPIRATION_TIME)).strftime(dt_format), 
            'sub': sub, 
            # TODO plan the aud and Resource Servers
            'aud':  aud,
            # 'nbf': now.strftime(dt_format), 
            # 'iat': now.strftime(dt_format),
            # 'jti': uuid.uuid4().hex,
            'remote': remote, 
            'role': role}